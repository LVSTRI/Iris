#version 460 core
#define INVOCATION_SIZE 256

struct indirect_command_t {
    uint count;
    uint instance_count;
    uint first_index;
    int base_vertex;
    uint base_instance;
};

struct object_info_t {
    uint local_transform;
    uint global_transform;
    uint diffuse_texture;
    uint normal_texture;
    uint specular_texture;
    uint group_index;
    uint group_offset;

    indirect_command_t command;
};

struct object_index_shift_t {
    uint object_id;
};

layout (local_size_x = INVOCATION_SIZE, local_size_y = 1, local_size_z = 1) in;

layout (location = 0) uniform uint u_draw_count;
layout (location = 1) uniform uint u_object_count;

layout (std140, binding = 0) uniform u_camera {
    mat4 projection;
    mat4 view;
    mat4 pv;
    vec3 position;
    float near;
    float far;
} camera;

layout (std430, binding = 1) readonly restrict buffer b_local_transform {
    mat4[] local_transforms;
};

layout (std430, binding = 2) readonly restrict buffer b_global_transform {
    mat4[] global_transforms;
};

layout (std430, binding = 3) readonly restrict buffer b_object_info {
    object_info_t[] objects;
};

layout (std430, binding = 4) writeonly restrict buffer b_indirect_commands {
    indirect_command_t[] indirect_commands;
};

layout (std430, binding = 5) writeonly restrict buffer b_draw_count {
    uint[] draw_count;
};

layout (std430, binding = 6) writeonly restrict buffer b_object_index_shift {
    object_index_shift_t[] object_shift;
};

bool is_object_visible(in object_info_t object, in mat4 model) {
    return true;
}

void main() {
    const uint index = gl_GlobalInvocationID.x;
    if (index == 0) {
        for (uint i = 0; i < u_draw_count; ++i) {
            draw_count[i] = 0;
        }
    }
    barrier();
    if (index < u_object_count) {
        const object_info_t object = objects[index];
        const mat4 local_transform = local_transforms[object.local_transform];
        const mat4 global_transform = global_transforms[object.global_transform];
        const mat4 model = global_transform * local_transform;
        if (is_object_visible(object, model)) {
            const uint slot = atomicAdd(draw_count[object.group_index], 1);
            indirect_commands[slot + object.group_offset] = object.command;
            object_shift[slot + object.group_offset].object_id = index;
        }
    }
}
